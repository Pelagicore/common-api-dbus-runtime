/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.3.qualifier.
* Used org.franca.core 0.8.10.201309262002.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef COMMONAPI_TESTS_Derived_Type_Collection_H_
#define COMMONAPI_TESTS_Derived_Type_Collection_H_


#include <commonapi/tests/PredefinedTypeCollection.h>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace commonapi {
namespace tests {

namespace DerivedTypeCollection {
    struct TestStruct: CommonAPI::SerializableStruct {
        /**
         * the name of the property
         */
         PredefinedTypeCollection::TestString testString;
        /**
         * the actual value
         */
         uint16_t uintValue;
    
        TestStruct() = default;
        TestStruct(const PredefinedTypeCollection::TestString& testString, const uint16_t& uintValue);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
        }
    };
    typedef std::vector<TestStruct> TestArrayTestStruct;
    typedef std::unordered_map<uint32_t, TestArrayTestStruct> TestMap;
    /**
     * Common errors.
     */
    enum class TestEnum: int32_t {
        /**
         * default
         */
        E_UNKNOWN = 0x0,
        /**
         * no error - positive reply
         */
        E_OK = 0x1,
        /**
         * value out of range
         */
        E_OUT_OF_RANGE = 0x2,
        /**
         * not used
         */
        E_NOT_USED = 0x3
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct TestEnumComparator;
    enum class TestEnumExtended: int32_t {
        E_UNKNOWN = TestEnum::E_UNKNOWN,
        E_OK = TestEnum::E_OK,
        E_OUT_OF_RANGE = TestEnum::E_OUT_OF_RANGE,
        E_NOT_USED = TestEnum::E_NOT_USED
        ,
        /**
         * new error
         */
        E_NEW = 0x4
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct TestEnumExtendedComparator;
    enum class TestEnumExtended2: int32_t {
        E_UNKNOWN = TestEnum::E_UNKNOWN,
        E_OK = TestEnum::E_OK,
        E_OUT_OF_RANGE = TestEnum::E_OUT_OF_RANGE,
        E_NOT_USED = TestEnum::E_NOT_USED,
        
        E_NEW = TestEnumExtended::E_NEW
        ,
        /**
         * new error
         */
        E_NEW2 = 0x5
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct TestEnumExtended2Comparator;
    struct TestStructExtended: TestStruct {
         TestEnumExtended2 testEnumExtended2;
    
        TestStructExtended() = default;
        TestStructExtended(const PredefinedTypeCollection::TestString& testString, const uint16_t& uintValue, const TestEnumExtended2& testEnumExtended2);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            TestStruct::writeToTypeOutputStream(typeOutputStream);
            typeOutputStream.writeInt32Type();
        }
    };
    typedef std::unordered_map<TestEnum, std::string, CommonAPI::EnumHasher<TestEnum>> TestEnumMap;
    enum class TestEnumMissingValue: int32_t {
        /**
         * default
         */
        E1 = 0xa,
        E2,
        E3 = 2
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct TestEnumMissingValueComparator;
    typedef std::vector<uint64_t> TestArrayUInt64;
    struct TestPolymorphicStruct: CommonAPI::SerializablePolymorphicStruct {
        /**
         * the name of the property
         */
         PredefinedTypeCollection::TestString testString;
        /**
         * the actual value
         */
         uint16_t uintValue;
    
        TestPolymorphicStruct() = default;
        TestPolymorphicStruct(const PredefinedTypeCollection::TestString& testString, const uint16_t& uintValue);
    
        enum: uint32_t { SERIAL_ID = 0x34650f46 };
    
        static TestPolymorphicStruct* createInstance(const uint32_t& serialId);
    
        virtual uint32_t getSerialId() const;
        virtual void createTypeSignature(CommonAPI::TypeOutputStream& typeOutputStream) const;
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
        }
    };
    struct TestExtendedPolymorphicStruct: TestPolymorphicStruct {
         uint32_t additionalValue;
    
        TestExtendedPolymorphicStruct() = default;
        TestExtendedPolymorphicStruct(const PredefinedTypeCollection::TestString& testString, const uint16_t& uintValue, const uint32_t& additionalValue);
    
        enum: uint32_t { SERIAL_ID = 0xc967fead };
    
        static TestExtendedPolymorphicStruct* createInstance(const uint32_t& serialId);
    
        virtual uint32_t getSerialId() const;
        virtual void createTypeSignature(CommonAPI::TypeOutputStream& typeOutputStream) const;
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            TestPolymorphicStruct::writeToTypeOutputStream(typeOutputStream);
            typeOutputStream.writeUInt32Type();
        }
    };
    typedef std::unordered_map<uint8_t, std::shared_ptr<TestPolymorphicStruct>> MapIntToPolymorphic;
    typedef std::unordered_map<std::shared_ptr<TestPolymorphicStruct>, uint8_t> MapPolymorphicToInt;
    struct StructWithPolymorphicMember: CommonAPI::SerializableStruct {
         uint32_t numberValue;
         std::shared_ptr<TestPolymorphicStruct> polymorphicMember;
    
        StructWithPolymorphicMember() = default;
        StructWithPolymorphicMember(const uint32_t& numberValue, const std::shared_ptr<TestPolymorphicStruct>& polymorphicMember);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeStringType();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
        }
    };
    struct StructWithEnumKeyMap: CommonAPI::SerializableStruct {
         TestEnumMap testMap;
    
        StructWithEnumKeyMap() = default;
        StructWithEnumKeyMap(const TestEnumMap& testMap);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.beginWriteMapType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeStringType();
            typeOutputStream.endWriteMapType();
        }
    };

bool operator==(const TestStructExtended& lhs, const TestStructExtended& rhs);
inline bool operator!=(const TestStructExtended& lhs, const TestStructExtended& rhs) {
    return !(lhs == rhs);
}
inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, TestEnum& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const TestEnum& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct TestEnumComparator {
    inline bool operator()(const TestEnum& lhs, const TestEnum& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, TestEnumExtended2& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const TestEnumExtended2& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct TestEnumExtended2Comparator {
    inline bool operator()(const TestEnumExtended2& lhs, const TestEnumExtended2& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};


inline bool operator==(const TestEnumExtended2& lhs, const DerivedTypeCollection::TestEnum& rhs) {
    return static_cast<int32_t>(lhs) == static_cast<int32_t>(rhs);
}
inline bool operator==(const DerivedTypeCollection::TestEnum& lhs, const TestEnumExtended2& rhs) {
    return static_cast<int32_t>(lhs) == static_cast<int32_t>(rhs);
} 
inline bool operator!=(const TestEnumExtended2& lhs, const DerivedTypeCollection::TestEnum& rhs) {
    return static_cast<int32_t>(lhs) != static_cast<int32_t>(rhs);
}
inline bool operator!=(const DerivedTypeCollection::TestEnum& lhs, const TestEnumExtended2& rhs) {
    return static_cast<int32_t>(lhs) != static_cast<int32_t>(rhs);
} 

inline bool operator==(const TestEnumExtended2& lhs, const DerivedTypeCollection::TestEnumExtended& rhs) {
    return static_cast<int32_t>(lhs) == static_cast<int32_t>(rhs);
}
inline bool operator==(const DerivedTypeCollection::TestEnumExtended& lhs, const TestEnumExtended2& rhs) {
    return static_cast<int32_t>(lhs) == static_cast<int32_t>(rhs);
} 
inline bool operator!=(const TestEnumExtended2& lhs, const DerivedTypeCollection::TestEnumExtended& rhs) {
    return static_cast<int32_t>(lhs) != static_cast<int32_t>(rhs);
}
inline bool operator!=(const DerivedTypeCollection::TestEnumExtended& lhs, const TestEnumExtended2& rhs) {
    return static_cast<int32_t>(lhs) != static_cast<int32_t>(rhs);
} 
inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, TestEnumMissingValue& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const TestEnumMissingValue& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct TestEnumMissingValueComparator {
    inline bool operator()(const TestEnumMissingValue& lhs, const TestEnumMissingValue& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, TestEnumExtended& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const TestEnumExtended& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct TestEnumExtendedComparator {
    inline bool operator()(const TestEnumExtended& lhs, const TestEnumExtended& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};


inline bool operator==(const TestEnumExtended& lhs, const DerivedTypeCollection::TestEnum& rhs) {
    return static_cast<int32_t>(lhs) == static_cast<int32_t>(rhs);
}
inline bool operator==(const DerivedTypeCollection::TestEnum& lhs, const TestEnumExtended& rhs) {
    return static_cast<int32_t>(lhs) == static_cast<int32_t>(rhs);
} 
inline bool operator!=(const TestEnumExtended& lhs, const DerivedTypeCollection::TestEnum& rhs) {
    return static_cast<int32_t>(lhs) != static_cast<int32_t>(rhs);
}
inline bool operator!=(const DerivedTypeCollection::TestEnum& lhs, const TestEnumExtended& rhs) {
    return static_cast<int32_t>(lhs) != static_cast<int32_t>(rhs);
} 
bool operator==(const TestStruct& lhs, const TestStruct& rhs);
inline bool operator!=(const TestStruct& lhs, const TestStruct& rhs) {
    return !(lhs == rhs);
}
bool operator==(const TestPolymorphicStruct& lhs, const TestPolymorphicStruct& rhs);
inline bool operator!=(const TestPolymorphicStruct& lhs, const TestPolymorphicStruct& rhs) {
    return !(lhs == rhs);
}
bool operator==(const TestExtendedPolymorphicStruct& lhs, const TestExtendedPolymorphicStruct& rhs);
inline bool operator!=(const TestExtendedPolymorphicStruct& lhs, const TestExtendedPolymorphicStruct& rhs) {
    return !(lhs == rhs);
}
bool operator==(const StructWithPolymorphicMember& lhs, const StructWithPolymorphicMember& rhs);
inline bool operator!=(const StructWithPolymorphicMember& lhs, const StructWithPolymorphicMember& rhs) {
    return !(lhs == rhs);
}
bool operator==(const StructWithEnumKeyMap& lhs, const StructWithEnumKeyMap& rhs);
inline bool operator!=(const StructWithEnumKeyMap& lhs, const StructWithEnumKeyMap& rhs) {
    return !(lhs == rhs);
}


static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "commonapi.tests.DerivedTypeCollection";
    return typeCollectionName;
}


} // namespace DerivedTypeCollection

} // namespace tests
} // namespace commonapi

namespace CommonAPI {

    template<>
    struct BasicTypeWriter<commonapi::tests::DerivedTypeCollection::TestEnum> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnum> {
        static void beginReadVector(InputStream& inputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnum>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnum> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnum>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<commonapi::tests::DerivedTypeCollection::TestEnumExtended2> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnumExtended2> {
        static void beginReadVector(InputStream& inputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnumExtended2>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnumExtended2> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnumExtended2>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<commonapi::tests::DerivedTypeCollection::TestEnumMissingValue> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnumMissingValue> {
        static void beginReadVector(InputStream& inputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnumMissingValue>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnumMissingValue> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnumMissingValue>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<commonapi::tests::DerivedTypeCollection::TestEnumExtended> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnumExtended> {
        static void beginReadVector(InputStream& inputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnumExtended>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<commonapi::tests::DerivedTypeCollection::TestEnumExtended> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<commonapi::tests::DerivedTypeCollection::TestEnumExtended>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };

}


namespace std {
    //Hash for TestEnum
    template<>
    struct hash<commonapi::tests::DerivedTypeCollection::TestEnum> {
        inline size_t operator()(const commonapi::tests::DerivedTypeCollection::TestEnum& testEnum) const {
            return static_cast<int32_t>(testEnum);
        }
    };
    //Hash for TestEnumExtended2
    template<>
    struct hash<commonapi::tests::DerivedTypeCollection::TestEnumExtended2> {
        inline size_t operator()(const commonapi::tests::DerivedTypeCollection::TestEnumExtended2& testEnumExtended2) const {
            return static_cast<int32_t>(testEnumExtended2);
        }
    };
    //Hash for TestEnumMissingValue
    template<>
    struct hash<commonapi::tests::DerivedTypeCollection::TestEnumMissingValue> {
        inline size_t operator()(const commonapi::tests::DerivedTypeCollection::TestEnumMissingValue& testEnumMissingValue) const {
            return static_cast<int32_t>(testEnumMissingValue);
        }
    };
    //Hash for TestEnumExtended
    template<>
    struct hash<commonapi::tests::DerivedTypeCollection::TestEnumExtended> {
        inline size_t operator()(const commonapi::tests::DerivedTypeCollection::TestEnumExtended& testEnumExtended) const {
            return static_cast<int32_t>(testEnumExtended);
        }
    };
}

#endif // COMMONAPI_TESTS_Derived_Type_Collection_H_
