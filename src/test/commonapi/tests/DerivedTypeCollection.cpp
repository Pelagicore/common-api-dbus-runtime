/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.qualifier.
* Used org.franca.core 0.8.10.201309262002.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include "DerivedTypeCollection.h"


namespace commonapi {
namespace tests {
namespace DerivedTypeCollection {



TestStructExtended::TestStructExtended(const PredefinedTypeCollection::TestString& testStringValue, const uint16_t& uintValueValue, const TestEnumExtended2& testEnumExtended2Value):
        TestStruct(testStringValue, uintValueValue),
        testEnumExtended2(testEnumExtended2Value)
{
}


bool operator==(const TestStructExtended& lhs, const TestStructExtended& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        static_cast<TestStructExtended::TestStruct>(lhs) == static_cast<TestStructExtended::TestStruct>(rhs) &&
        lhs.testEnumExtended2 == rhs.testEnumExtended2
    ;
}

void TestStructExtended::readFromInputStream(CommonAPI::InputStream& inputStream) {
    TestStruct::readFromInputStream(inputStream);
    inputStream >> testEnumExtended2;
}

void TestStructExtended::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    TestStruct::writeToOutputStream(outputStream);
    outputStream << testEnumExtended2;
}








TestStruct::TestStruct(const PredefinedTypeCollection::TestString& testStringValue, const uint16_t& uintValueValue):
        testString(testStringValue),
        uintValue(uintValueValue)
{
}


bool operator==(const TestStruct& lhs, const TestStruct& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.testString == rhs.testString &&
        lhs.uintValue == rhs.uintValue
    ;
}

void TestStruct::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> testString;
    inputStream >> uintValue;
}

void TestStruct::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << testString;
    outputStream << uintValue;
}

TestPolymorphicStruct::TestPolymorphicStruct(const PredefinedTypeCollection::TestString& testStringValue, const uint16_t& uintValueValue):
        testString(testStringValue),
        uintValue(uintValueValue)
{
}

TestPolymorphicStruct* TestPolymorphicStruct::createInstance(const uint32_t& serialId) {
    if (serialId == SERIAL_ID)
        return new TestPolymorphicStruct;

    const std::function<TestPolymorphicStruct*()> createDerivedInstanceFuncs[] = {
        [&]() { return TestExtendedPolymorphicStruct::createInstance(serialId); }
    };

    for (auto& createDerivedInstanceFunc : createDerivedInstanceFuncs) {
        TestPolymorphicStruct* derivedInstance = createDerivedInstanceFunc();
        if (derivedInstance != NULL)
            return derivedInstance;
    }

    return NULL;
}

uint32_t TestPolymorphicStruct::getSerialId() const {
    return SERIAL_ID;
}

void TestPolymorphicStruct::createTypeSignature(CommonAPI::TypeOutputStream& typeOutputStream) const {
    TestPolymorphicStruct::writeToTypeOutputStream(typeOutputStream);
}

bool operator==(const TestPolymorphicStruct& lhs, const TestPolymorphicStruct& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.testString == rhs.testString &&
        lhs.uintValue == rhs.uintValue
    ;
}

void TestPolymorphicStruct::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> testString;
    inputStream >> uintValue;
}

void TestPolymorphicStruct::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << testString;
    outputStream << uintValue;
}

TestExtendedPolymorphicStruct::TestExtendedPolymorphicStruct(const PredefinedTypeCollection::TestString& testStringValue, const uint16_t& uintValueValue, const uint32_t& additionalValueValue):
        TestPolymorphicStruct(testStringValue, uintValueValue),
        additionalValue(additionalValueValue)
{
}

TestExtendedPolymorphicStruct* TestExtendedPolymorphicStruct::createInstance(const uint32_t& serialId) {
    if (serialId == SERIAL_ID)
        return new TestExtendedPolymorphicStruct;

    return NULL;
}

uint32_t TestExtendedPolymorphicStruct::getSerialId() const {
    return SERIAL_ID;
}

void TestExtendedPolymorphicStruct::createTypeSignature(CommonAPI::TypeOutputStream& typeOutputStream) const {
    TestExtendedPolymorphicStruct::writeToTypeOutputStream(typeOutputStream);
}

bool operator==(const TestExtendedPolymorphicStruct& lhs, const TestExtendedPolymorphicStruct& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        static_cast<TestExtendedPolymorphicStruct::TestPolymorphicStruct>(lhs) == static_cast<TestExtendedPolymorphicStruct::TestPolymorphicStruct>(rhs) &&
        lhs.additionalValue == rhs.additionalValue
    ;
}

void TestExtendedPolymorphicStruct::readFromInputStream(CommonAPI::InputStream& inputStream) {
    TestPolymorphicStruct::readFromInputStream(inputStream);
    inputStream >> additionalValue;
}

void TestExtendedPolymorphicStruct::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    TestPolymorphicStruct::writeToOutputStream(outputStream);
    outputStream << additionalValue;
}


StructWithPolymorphicMember::StructWithPolymorphicMember(const uint32_t& numberValueValue, const std::shared_ptr<TestPolymorphicStruct>& polymorphicMemberValue):
        numberValue(numberValueValue),
        polymorphicMember(polymorphicMemberValue)
{
}


bool operator==(const StructWithPolymorphicMember& lhs, const StructWithPolymorphicMember& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.numberValue == rhs.numberValue &&
        lhs.polymorphicMember == rhs.polymorphicMember
    ;
}

void StructWithPolymorphicMember::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> numberValue;
    inputStream >> polymorphicMember;
}

void StructWithPolymorphicMember::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << numberValue;
    outputStream << polymorphicMember;
}

StructWithEnumKeyMap::StructWithEnumKeyMap(const TestEnumMap& testMapValue):
        testMap(testMapValue)
{
}


bool operator==(const StructWithEnumKeyMap& lhs, const StructWithEnumKeyMap& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.testMap == rhs.testMap
    ;
}

void StructWithEnumKeyMap::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> testMap;
}

void StructWithEnumKeyMap::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << testMap;
}

} // namespace DerivedTypeCollection
} // namespace tests
} // namespace commonapi
